// Copyright (C) 2009, 2010 by Florent Lamiraux, Thomas Moulard, JRL.
//
// This file is part of the hpp-corbaserver.
//
// This software is provided "as is" without warranty of any kind,
// either expressed or implied, including but not limited to the
// implied warranties of fitness for a particular purpose.
//
// See the COPYING file for more information.

#ifndef HPP_CORBASERVER_PROBLEM_SERVER_IDL
# define HPP_CORBASERVER_PROBLEM_SERVER_IDL
# include <hpp/corbaserver/common.idl>

module hpp
{
  module corbaserver {
  /// \brief To define and solve a path planning problem.
  interface Problem
  {
    /// \name Initial and goal configurations
    /// \{

    /// Set initial configuration of specified problem.
    ///	\param dofArray Array of degrees of freedom
    ///	\throw Error.
    void setInitialConfig (in floatSeq dofArray) raises (Error);

    /// Get initial configuration of specified problem.
    ///	\return Array of degrees of freedom
     floatSeq getInitialConfig () raises (Error);

    /// \brief Add goal configuration to specified problem.
    ///	\param dofArray Array of degrees of freedom
    ///	\throw Error.
    void addGoalConfig (in floatSeq dofArray) raises (Error);

    /// Get goal configurations of specified problem.
    ///	\return Array of degrees of freedom
    floatSeqSeq getGoalConfigs () raises (Error);

    /// Reset goal configurations
    void resetGoalConfigs () raises (Error);

    /// \}

    /// \name Constraints
    /// \{

    /// Apply constaints to a configuration
    ///
    /// constraints are stored in ProblemSolver object
    void applyConstraints (in floatSeq input, out floatSeq output)
      raises (Error);


    /// Apply position constraints to a configuration
    ///
    /// constraints are stored in ProblemSolver object
    void createPositionConstraints (in floatSeq input, out floatSeq output)
      raises (Error);

    /// Reset constraints
    void resetConstraints () raises (Error);

    /// Set numerical constraints by names in ConfigProjector
    /// \param constraintName Name of the set of numerical constraint,
    /// \param constraintNames names of the constraints to apply,
    ///
    /// Constraints should have been added in the ProblemSolver local map.
    void setNumericalConstraints (in string constraintName,
				  in Names_t constraintNames)
      raises (Error);
    
    /// Lock degree of freedom with given value
    /// \param jointName name of the joint
    /// \param value value of the locked degree of freedom.
    void lockDof (in string jointName, in double value) raises (Error);

    /// Set error threshold in numerical constraint resolution
    void setErrorThreshold (in double threshold) raises (Error);

    /// Set maximal number of iterations in numerical constraint resolution
    void setMaxIterations (in unsigned short iterations) raises (Error);

    /// \}

    /// \name Solve problem and get paths
    /// \{

    // \brief Solve the problem of corresponding ChppPlanner object
    // \throw Error.
    void solve() raises (Error);

    /// Make direct connection between two configurations
    /// \param startConfig, endConfig: the configurations to link.
    /// \throw Error if steering method fails to create a direct path of if
    /// direct path is not valid
    void directPath (in floatSeq startConfig, in floatSeq endConfig)
      raises (Error);

    /// Get Number of paths
    short numberPaths () raises (Error);

    // Optimize a given path
    // \param inPathId Id of the path in this problem.
    // \throw Error.
    void optimizePath(in unsigned short inPathId) raises (Error);

    // Get length of path
    // \param inPathId rank of the path in the problem
    // \return length of path if path exists.
    double pathLength(in unsigned short inPathId) raises (Error);

     // Get the robot's config at param on the a path
     // \param inPathId rank of the path in the problem
     // \param atDistance : the user parameter choice
     // \return dofseq : the config at param
    floatSeq configAtDistance(in unsigned short inPathId, in double atDistance)
      raises (Error);

    /// \}

    /// \name Interruption of a path planning request
    /// \{

    /// \brief Interrupt path planning activity
    /// \note this request is effective only when multi-thread policy is used
    ///       by CORBA server.
    /// See constructor of class Server for details.
    void interruptPathPlanning() raises (Error);
    ///\}

    /// \name exploring the roadmap
    /// \{

    /// Nodes of the roadmap
    floatSeqSeq nodes () raises (Error);

    /// Number of edges
    long numberEdges () raises (Error);

    /// Edge at given rank
    void edge (in unsigned long edgeId, out floatSeq q1, out floatSeq q2)
      raises (Error);

    /// Number of connected components
    long numberConnectedComponents ();

    /// Nodes of a connected component
    /// \param connectedComponentId index of connected component in roadmap
    /// \return list of nodes of the connected component.
    floatSeqSeq nodesConnectedComponent (in unsigned long connectedComponentId)
      raises (Error);

    /// Clear the roadmap
    void clearRoadmap () raises (Error);
    /// \}
  };
  }; // interface Problem
}; // module hpp
#endif
